# 4. Gitting things done

## Lesson Objectives
In this lesson, we will:
- create a local Git repository
- introduce ourselves to Git
- learn how to organize and track our changes with Git

## Terminology Covered
- **to commit (v.)** -- to save the state of all of your files in the repository.
  - _I committed the changes to the repository._
- **commit (n.)** -- an individual instance of a committing event. A snapshot of the repository in time.
  - _The last commit introduced a bug in the program._
- **changeset** -- a set of changes which should be treated as an indivisible group.
- **to stage (v.)** -- to bundle files together *in preparation* of a commit (i.e., saving the state to the repo).
- **staging area (n.)** -- the digital "space" where staging takes place. Changes must first be added to the staging area before you can commit them.

## Commands Covered
- `git init` -- Start a Git repository
- `git config --global <configuration option> "configuration value"` -- Change your global Git configuration file to add or set a configuration option value. Git uses this file to determine who you are, communicate with GitHub (or other Git resources), and remember your settings for using Git.
- `git status` -- Check the status of this repository (has anything changed?)
- `git diff` -- See the differences noted by `git status`
- `git add` -- Stage files whose changes you want to track
- `git commit --message "YOUR COMMIT MESSAGE"` -- Commit the changes to the Git repository with a descriptive message
- `git log` -- See a log of committed changes to the repository

-------------------------------------------------------------------------------------------------------------
## Initializing a local Git Repository
Congratulations, you are about to start actually using Git!

Remember, a local Git repository is just a directory that you tell Git to keep track of.
So let's make a fresh directory to get started:

```bash
cd ~/Desktop/2019_workshop/
mkdir git-lesson
```

Let's convert that directory into a Git repository:

```bash
cd git-lesson
git init
```

And voil√†! We have a Git repository!

### How do I know it worked?
Remember, Git repositories are just directories that contain a special `.git` directory inside them.
To see that this is the case, let's list **ALL** the contents of the `git-lesson` directory.

```bash
ls -a
```

You should see this:

```text
. ..  .git
```

Good. You have just created a local repository!

-------------------------------------------------------------------------------------------------------------
## Introduce yourself to Git!
Git works by creating special identifiers for changes that you make to files. These identifiers are generated in part based on the author of the changes (among many other things).

Consequently, Git needs to know who you are! Let's introduce ourselves to Git:

```bash
git config --global user.name "YOUR NAME HERE"
git config --global user.email "YOUR GITHUB EMAIL HERE"
```

By telling Git your name, you allow Git to tag your activity as being authored by you. By telling Git the email associated with your GitHub account, you allow for communication between the Git installed on your computer, and the Git used on GitHub. More about this later!

This introduction was a one-time thing. Now you are ready to use Git!

-------------------------------------------------------------------------------------------------------------
## A (local) Git-based Work Cycle
Ok, so we have a Git repository. Now...how do we use it?

We'll go through this step-by-step shortly, but let's preview a good work cycle to use with Git:
1. Do some work. It's a good idea to work on small, easily describable chunks.
2. `git status`: ask Git to give you a status report to assess the changes you made.
3. `git diff`: ask Git for a more detailed report of the changes you made.
4. `git add <file>`: add changes that you want to keep to the *staging area*.
5. `git status` (again): it's a really good idea to verify that Git thinks you added the same changes that you think you added.
6. `git commit --message "YOUR MESSAGE"`: commit the changes to the repository. This will create a commit that contains your message, which will be logged in the history of your repository forever :grin:
7. Rinse and repeat as desired.

We will expand on this recommended work cycle a little bit in the next lesson. But for now, let's put this work cycle into practice!

-------------------------------------------------------------------------------------------------------------
## Working with Git
Making sure we are in our repository...

```bash
cd ~/Desktop/2019_workshop
```

...let's start by adding a file to our repo:

```bash
touch readme.txt
ls
```

Ok, that worked like normal. We have a new file in the directory. What does Git think happened?

```bash
git status
```

Let's break down what Git is telling us, bit-by-bit:

```text
On branch master
```

Ok...what is a branch, and why is it called "master"?

In many cases, Git uses a tree analogy for terminology. You don't need to worry about this for now. Just know that "branching" is a powerful feature of Git. But remember, we are only using a hammer in this lesson, not the complicated swiss-army-hammer that is all of Git!

```text
No commits yet
```

Ok...what's a commit?

A **commit** is a snapshot of the repository in time. We will talk about commits shortly :grin:

```text
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    readme.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Ok, now this is the meat of the `git status` report. Git's job is to track files, right? Here it's telling us that there are files in the repository that it is *not tracking*. It even tells us how to start tracking those files or include them in a commit.

So why is our new file "untracked" even though Git's job is to track files, and Git sees that the file is there?

This is where **staging** comes in. In order to allow you to organize the changes you make in sensible chunks, Git adds an intermediate step between making a change and committing it. This allows you to, e.g., make many changes to different files, and then *commit only some of those changes to the repository*. The **staging area** is the place where those changes "go" in preparation for a commit.

<img src="/images/local_git.png" width="450">

[Image adapted from post by Zvonimir Spajic at HackerNoon (Medium)](https://medium.com/hackernoon/understanding-git-index-4821a0765cf)

Since we want to commit our new readme file to our repository, let's take Git's advice and *add readme.txt to the staging area*:

```bash
git add readme.txt
```

Let's see how this changed our `git status` report for the repository.

```bash
git status
```

Notice this part of the output:

```text
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   readme.txt
```

Now that we have *added readme.txt to the staging area*, Git tells us we have `changes to be committed` that includes a `new file: readme.txt`.

>Git is full of "helpful" advice (the advice gets more helpful as you get more used to Git's terminology). Here, Git tells us how to remove this change from the staging area if we don't want to commit it.

Ok, that's nice. But this file is empty. Let's try adding something to the file. To write into the file, open it with nano:

```bash
nano readme.txt
```

Write a line into the file (you can write whatever you want). When you are done, save it and exit nano.

Let's check in with Git again. What does it think we did?

```bash
git status
```

```text
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   readme.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   readme.txt
```

Notice what happened here. We had already added `readme.txt` to the staging area, which Git reports as `Changes to be committed` and refers to the `new file: readme.txt`. This part is exactly the same as it was before.

But Git also sees that we have made further changes that we have not added to the staging area. Git reports these as `Changes not staged for commit` and notes one such change (the only change we made): `modified: readme.txt`.

>So what do you think would happen if we committed our changes right now? What would `readme.txt` contain?

Now imagine that you had changed a lot inside of `readme.txt`. Perhaps you can't even remember what changes you made. Git can give you a more detailed picture:

```bash
git diff
```

You should get an output like the following, where the last line is whatever you added to `readme.txt`:

```text
diff --git a/readme.txt b/readme.txt
index e69de29..270c611 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1 @@
+hello, world!
```

>`git diff` is short for "show me the *difference* between my working copy and the staging area." Git uses `+` and `-` to indicate lines that are added or subtracted, respectively.

We like the line that we added to `readme.txt`, so let's add this change to the staging area:

```bash
git add readme.txt
```

Let's double-check that we are on the same page with Git:

```bash
git status
```

Notice that now we are back to just:

```text
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   readme.txt
```

>If we had wanted to keep the addition of the new file separate from the addition of the line of text in the file, we would have had to commit after we created the file, but before we added the line of text to the staging area.

We are pretty happy with this, so I think we are ready to make our first commit:

```bash
git commit --message "add readme"
```

>The message we attach to this commit could be anything we want. But it's a good idea to make your commit messages *precise*, *concise*, and *clear*. This comes with practice!

Let's see if the status of our repo is different now:

```bash
git status
```

We should see the following:

```text
On branch master
nothing to commit, working tree clean
```

Again, another tree analogy. Basically, Git is saying "your working copy of the repository matches the official current state of the repository".

Congratulations, you've worked through your first Git-based work cycle!

Before we end, let's do one final thing. Imagine you did this work, then you went on a long vacation. You just got back, and you want to pick up where you left off. Only problem is, you can't remember what you had been working on!

Git can help you here. You can see a log of your recent commits to help you remember what you had been doing:

```bash
git log
```

Notice that your output contains something like the following:

```text
commit d7d235517149fa309a792c132802b6e78a5469c8 (HEAD -> master)
Author: Noah Richard Nelson <noah.nelson.11@gmail.com>
Date:   Fri Oct 18 16:00:57 2019 -0700

    add readme

```

Hey, now we can see why we introduced ourselves to Git! It has our *user.name* and *user.email* in the `Author:` field!

The commit itself has an arbitrary character sequence (called a hash) as a label. This isn't very helpful to us right now. But, our commit message is there, floating in space, easy to find and read. ***This is why it is so valuable to write good commit messages - they are messages to your future self!***

-------------------------------------------------------------------------------------------------------------
## Exercise: DIY Git!
Using the same repo we were just working on, I want you to:
1. Add some more text into `readme.txt`
2. Add a new file to the repo called `practice.txt`
3. Make a separate commit for each of these two changes
4. How does the commit log look different now?

<details>
  <summary>Solution</summary>

  #### Add some more text into `readme.txt`
  <p>

  ```bash
  nano readme.txt
  ```

  </p>

  ...add text to the file, write out and exit nano (control+o, enter, control+x)

  #### Add a new file the repo called `practice.txt`
  <p>

  ```bash
  touch practice.txt
  ```

  </p>

  #### Make a separate commit for each of these two changes
  <p>

  ```bash
  git add readme.txt
  git status
  git commit --message "DIY exercise #1"
  ```

  </p>

  ...making the commit message whatever you want. Then:

  <p>

  ```bash
  git add practice.txt
  git status
  git commit --message "DIY exercise #2"
  ```

  </p>

  ...making the commit message whatever you want.

  #### How does the commit log look differnt?
  <p>

  ```bash
  git log
  ```

  </p>

  ...should give you an output like this:

  <p>

  ```text
  commit 0da02f5d54be96244daa90483a21dbdda4d6258b (HEAD -> master)
  Author: Noah Richard Nelson <noah.nelson.11@gmail.com>
  Date:   Fri Oct 18 16:00:57 2019 -0700

      DIY exercise #2

  commit 8fbe2c4bd8d93b0dd2e2efad19a0fd1d6071d53f
  Author: Noah Richard Nelson <noah.nelson.11@gmail.com>
  Date:   Fri Oct 18 15:56:22 2019 -0700

      DIY exercise #1

  commit d7d235517149fa309a792c132802b6e78a5469c8
  Author: Noah Richard Nelson <noah.nelson.11@gmail.com>
  Date:   Fri Oct 18 16:00:57 2019 -0700

      add readme

  ```

  </p>
</details>

## Congratulations, you now know how to use Git in a local repository!

-------------------------------------------------------------------------------------------------------------
# External Resources
